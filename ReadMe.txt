--------------------------------------------------------------------------------------------------
ИЕРАРХИЯ ФАЙЛОВ

AccauntsWebApp/
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   └── ru
│   │   │       ├── backend
│   │   │       │   ├── ExcelWorker.java
│   │   │       │   ├── HibernateSessionFactory.java
│   │   │       │   ├── MailManager.java
│   │   │       │   ├── StringConst.java
│   │   │       │   ├── UserInfo.java
│   │   │       │   └── WorkWithDatabase.java
│   │   │       ├── dao
│   │   │       │   ├── DateTableEntity.java
│   │   │       │   ├── DateTableEntityPK.java
│   │   │       │   ├── IntTableEntity.java
│   │   │       │   ├── IntTableEntityPK.java
│   │   │       │   ├── ListsTableEntity.java
│   │   │       │   ├── ListsTableEntityPK.java
│   │   │       │   ├── QuestionsEntity.java
│   │   │       │   ├── StrTableEntity.java
│   │   │       │   ├── StrTableEntityPK.java
│   │   │       │   └── UsersEntity.java
│   │   │       └── frontend
│   │   │           ├── AdminWorkServlet.java
│   │   │           ├── DataType.java
│   │   │           ├── RowUserTable.java
│   │   │           └── UserWorkServlet.java
│   │   └── resources
│   │       ├── CreateTables.sql
│   │       └── hibernate.cfg.xml
│   └── test
│       └── java
└── web
    ├── admin.html
    ├── index.html
    ├── resources
    │   ├── excels
    │   │   └── empty.txt
    │   ├── js
    │   │   ├── adminAppControllers.js
    │   │   ├── app.js
    │   │   └── userAppControllers.js
    │   └── libs
    │       └── angular-1.5.7
    │           ├── angular.min.js
    │           └── angular-route.min.js
    ├── templates
    │   ├── AppForAdmin
    │   │   ├── getInfoAboutUsers.html
    │   │   ├── homeAdmin.html
    │   │   ├── listEditor.html
    │   │   └── questionsEditor.html
    │   └── AppForUser
    │       ├── login.html
    │       ├── specifyUserId.html
    │       ├── successPage.html
    │       └── userInfoTable.html
    ├── user.html
    └── WEB-INF
        └── web.xml


--------------------------------------------------------------------------------------------------
ЛОГИКА РАБОТЫ И JSON'Ы

Общее
 Все запросы, отправляемые от клиента на сервер - это post-запросы. Интерфейс для пользователя
 осуществлён с использованием технологии AJAX.

Логика работы с пользователем

 0. Открывается страница user.html, которая является каркасом приложения для работы с
    пользователем. Этот каркас отображается всегда.

 1. Открывается шаблон login.html. Ожидается ввод имени и фамилии требуемого пользователя.
    По окончании ввода формируется
    json (на сервер):
    { 
     goal : "getUserInfo",
     data : { 
             name : "Bob",
             surname : "Bobovich",
             isNewUser: true
            }
    }

 2. Json отправляется в сервлет UserWorkServlet по адресу /userWork. Сервлет ищет в базе
    пользователя по заданным имени и фамилии. Если пользователь не найден или указан флаг isNewUser,
    то в базе создаётся новый пользователь, и подготавливается json (см. 4), информация из
    которого будет преобразована в таблицу в шаблоне userInfoTable.html. Если было найдено несколько
    пользователей с одинаковым именем и фамилией, то формируется json (см. 3), в котором
    содержатся все найденные Id, и пользователю отображается шаблон specifyUserId.html.

 3. Если пользователей с одинаковым именем и фамилией несколько, то от сервера приходит
    json (клиенту):
    {
     goal : "specifyUserId",
     name : "Bob",
     surname : "Bobovich",
     ids : [ 1, 2, 3, ...]
    }
    Эта информация отображается в шаблоне specifyUserId.html. После того, как пользователь выбрал
    конкретный Id, на сервер отправляется
    json (на сервер):
    {
     goal : "specifyUserId",
     data : {
             id : 1,
             name : "Bob",
             surname : "Bobovich"
            }
    }

 4. После однозначного определения пользователя, информацию о котором необходимо получить,
    формируется
    json (клиенту):
    {
     goal : "showUserInfo",
     name : "Bob",
     surname : "Bobovich",
     id : 1,
     data : [
             {
              id : 1,
              text : "Project",
              type : 3,
              value : "Super",
              format : [ "Super", "Duper", "Uber"]
             },
             {
              id : 2,
              text : "inner key",
              type : 0,
              value : "1234567890",
              format : 9
             },
             ...
            ]
    }
    Выводом этого json занимается шаблон userInfoTable.html. Обращаем внимание на особенность: если
    типом данных является Lists (выпадающий список), то в поле format храниться массив вариантов
    ответа; а если другой тип (не Lists), то format содержит индекс шаблона, который используется 
    страницами. Все шаблоны описаны в файле app.js и храняться в глобальном объекте dataFormats.
    
 5. По завершении изменения информации пользователем и нажатием соответствующей кнопки, на сервер
    передается такой же json, что описанный в пункте 4, однако в goal записано "updateUserInfo".
    После удачного (или не удачного) обнавления данных пользователя формируется
    json (клиенту):
    {
     message : "success",
     status : 0
    }
    В случае возникновения ошибки status равен 1, а message содержит сообщение исключения. 
    Сформированный json передаётся на обработку шаблону successPage.html.
    
    
    
Логика работы с администратором

 0. Открывается страница admin.html, которая является каркасом приложения для работы с
    администратором. Этот каркас отображается всегда.
    Администратор может:
    - редактировать списов вопросов, на котрые может ответить пользователь. Сюда же включается
      добавление нового вопроса, выставление видимости вопроса, настройка шаблона вводимой
      информации.
    - редактировать выпадающие списки, а именно добавлять варианты ответов (удаление не реализовано)
    - запрашивать xls-файл с информацией о конкретных пользователях.
    - настраивать периодическую отправку статистики по email.
    Все режимы перечислены в шаблоне homeAdmin.html.
    
 1. При переходе в режим редактирования вопросов, т.е. при загрузке шаблона questionEditor.html,
    клиент отправляет на сервер
    json (на сервер):
    {
     goal : "getQuestionsList"
    }
    В ответ сервер передаёт
    json (клиенту):
    {
     questions : [
                  {
                   text : "Project",
                   visible : 1,
                   format : 0,
                   type : 3,
                   change : 0,
                   id : 1
                  },
                  ...
                 ]
    }
    , где change - это возможность администратору вносить изменение в этот вопрос (0 - не может),
    id - номер вопроса.
    Предполагается, что при выставлении типа ответа "Список" (list) шаблон будет 0 (т.е. any). Важно
    подчеркнуть, что ограничений на выставления шаблона ввода нет, т.е. на тип int можно выставить
    шаблон "только буквы" (chars).
    По окончании редактирования клиент передаёт
    json (серверу):
    {
     goal : "updateQuestionsList",
     data : [
             {
              text : "Project",
              visible : 1,
              format : 0,
              type : 3,
              change : 0,
              id : 1
             },
             ...
            ]
    }
    Сервер обновляет вопросы и передаёт клиенту
    json (клиетну):
    {
     msg : "QuestionsList is update"
    }
    На это клиент переходит на шаблон homeAdmin.html и отображает присланное сообщение.
    
 2. При переходе в режим, позволяющий получить подробную информацию о пользователе или настроить
    переодическую отправку статистики по email, т.е. при загрузке шаблона getInfoAboutUser.html,
    клиент отправляет на сервер
    json (на сервер):
    {
     goal : "getUsersListAndMailSettings"
    }
    В ответ сервер передаёт
    json (клиенту):
    {
     users : [
              {
               id : 1,
               text : "[1] Bob Bobovich"                  
              },
              ...
             ],
     email : {
              address : "admin@admin.admin",
              delayMinForSend : 100,
              delayMinForControl : 100,
              enableTransmit : false
             }
    }
    , т.е. список всех поьзователей и настройки mailManager'а.
 
 2.1. 
    Администратор имеет возможность выбрать несколько пользователей, для которых необходимо
    сформировать xls-файл. По нажатии кнопки получения файла, клиент отправляет
    json (на сервер):
    {
     goal : "sendUsersInfo",
     data : [ 1, 2 ]
    }
    , где data - массив id пользователей, информацию о которых администратор хочет получить.
    Сервер отвечает адресом на скачивание файла.
    json (клиенту):
    {
     filepath : "/resources/excels/file_12_12_12.xls"
    }
    Далее по этому адресу осуществляется скачивание администратором файла.
    
 2.2.
    Администратор имеет возможность настроить отправку по email:
    - на какой адрес отправлять,
    - как часто отправлять,
    - за какой период формировать статистику.
    По окончании формирования настроек, передаётся
    json (на сервер):
    {
     goal : "updateMailManagerSettings",
     data : {
             address : "admin@admin.admin",
             delayMinForSend : 100,
             delayMinForControl : 100,
             enableTransmit : true
            }
    }
    Сервер отвечает
    json (клиенту):
    {
     msg : "Success"
    }
    На это клиент переходит на шаблон homeAdmin.html и отображает присланное сообщение.
    
 3. При переходе в режим редактирования списков, т.е. при загрузке шаблона listEditor.html,
    клиент отправляет на сервер
    json (на сервер):
    {
     goal : "getListNames"
    }
    В ответ сервер передаёт
    json (клиенту):
    {
     variants : [
                 {
                  id : 1,
                  text : "Project"                  
                 },
                 ...
                ]
    }
    , т.е. список вопросов, в которых ответ выбирается из выпадающего списка.
    Администратор выбирает вопрос и жмет на кнопку получения. На сервер передаётся
    json (на сервер):
    {
     goal : "getListContent",
     idQuestion : 1
    }
    Сервер отвечает списком вариантов ответа.
    json (клиенту):
    {
     texts : [ "Super", "Duper", "Uber"]
    }
    После добавления новых вариантов ответа администратором, передаётся
    json (на сервер):
    {
     goal : "updateList",
     data : {
             id : 1,
             text : [ "Super", "Duper", "Uber", "Puper"]
            }
    }
    Сервер обнавляет список вариантов ответа о передаёт клиенту
    json (клиенту):
    {
     msg : "Successful update"
    }
    Ответ отображается на том же шаблоне listEditor.html.


--------------------------------------------------------------------------------------------------
СБОРКА ПРОЕКТА ИЗ ИСХОДНОГО КОДА

Сборка приложения происходит в IDE IntelliJ IDEA Ultimate 2016.1. Контейнер - Apache Tomcat 9.

 1. Создаём пустой проект Maven без использования архетипов.
 2. В файл pom.xml прописываем зависимости. (см. pom.xml)
 3. Создаём базу данных Accaunts в СУБД MySQL 5.5. Для этого используем файл CreateTables.sql.
 4. Подключаемся к созданной базе. Справа вкладка Database. Жмём "+". Выбираем MySQL. Вводим
    параметры и проверяем соединение.
 5. В качестве модулей подключаем к проекту Web и Hibernate. Для этого в настройках проекта
    File-->Project Structure... (Ctrl+Alt+Shift+S) во вкладке Modules жмем слева сверху на "+". При
    добавлении Hibernate справа сверху жмём на "+" и добавляем hibernate.cfg.xml. При добавлении Web
    оставляем всё без изменений. Пункты 6-12 можно пропустить, так как иерархия файлов и основные
    настройки в xml уже выполнены. Требуется только обратить внимание на пункт 8.
 6. В папочке src/main/java создаём пакеты ru.dao, ru.frontend, ru.backend.
 7. Далее займёмся создание объектов из базы. Слева снизу открываем вкладку Persistence. ПКМ по
    названию проекта. Выбираем Generate Persistence Mapping-->By Database Schema. Выбираем
    установленное ранее подключение к БД. Обязательно проверяем, чтобы Package был ru.dao,
    suffix - Entity. Выбраны "prefer primitive types", "Show default relationship",
    "Add Session Factory", "Generate Column Properties","Generate JPA Annotations(Java5)". Выбираем
    все таблицы и жмём OK.
 8. Редактируем файл hibernate.cfg.xml. Добавляем диалект MySQL, имя пользователя и пароль
    пользователя, под которым будет работать hibernate. (см. hibernate.cfg.xml)
 9. Правим сгенерированные классы:
    - В классы с PK в @Column добавиляем "insertable = false, updatable = false" (без кавычек);
    - В классы Date-, Int-, Lists, StrTableEntity в связи в графе @JoinColumn добавляем
      "nullable = false, insertable = false, updatable = false".
    - В классах UsersEntity и QuestionsEntity пытаемся получить
      @Id
      @GenericGenerator(name = "gen", strategy = "increment")
      @GeneratedValue(generator = "gen")
      @Column(name = "id", nullable = false)
      Таким образом настраивается AUTO_INCREMENT для полей, на которых он задан в БД.
10. Добавим скаченные Maven'ом зависимости. Настройка проекта (Ctrl+Alt+Shift+S), Artifacts.
    Добавляем все доступные.
11. Распределяем классы по пакетам. (см. иерархию)
12. Проверяем в наличии web.xml welcome-list.
13. Настройка запуска. Run-->Edit configurations... Слева сверху жмём "+". Выбираем
    Tomcat Server-->Local. Помимо настроек добавляем во вкладке Deployment, нажав на "+" справа,
    артифакты.
14. Готово.

P.S. Важно отметить, что сервлет не хочет аккуратно завершаться.


--------------------------------------------------------------------------------------------------
НЕКОРРЕКТНОСТИ

1. Приложение не может завершиться само. Лезут варнинги. Проблема возникает после того, как
   создасться хотя бы один сервлет (или запустится hibernate).

2. Если во время работы с пользователем надать на кнопку браузера "назад", то произойдёт
    некорректное отображение содержимого и переменных js.

3. Не реализована передача по email xls-файлов.

4. Ничто не контролирует порядок следования вопросов.

5. Однажды введённую дату нельзя заменить на пустую строку (т.е. нельзя удалить).

6. В базе хранятся даты, записанные с помощью функции TIMESTEMP, в связи с чем если пользователь
   вводи дату до 1970-01-01 00:00:01 с учётом часового пояса сервера, то java.Sql кидает исключение,
   что, мол, дата кривая. Например, если серв в Питере, то корректная дата будет от 1970-01-01
   03:00:01 включительно, а вот от с 1970-01-01 03:00:00 будут сыпаться ошибки.
   UPD. Пытался найти верхний предел. Остановился на корректности даты 2038-01-01 00:00:01. Дальше
        лень тестировать. Но 2038-12-31 00:00:00 уже не работало.

7. Для произвольного типа данных можно установить любой pattern проверки. Например, если тип
   данных вопроса - число, то в проверяющем шаблоне всё равно можно задать
   "только буквы" и в таком роде.


--------------------------------------------------------------------------------------------------
ОСОБЕННОСТИ

1. То, что необходимо паказывать во всплывающем списке, храниться в таблице StrTable. При этом сам
   список хранится в поле format объекта json ввиде массива строк.

2. Почта отсылается только в том случае, если были изменения за заданный промежуток времени.

3. Чтобы tomcat создал папку excels, необходимо добавить в неё непустой файл.

4. На кнопки типа "Отправить", "Войти", "Обновить" можно нажать только один раз.

5. Чтобы изменить формат отображения/ввода даты и времени в соответствующих полях, необходимо
   1) MainServlet.getUserInfoByIdAndFormTableInfo : в части, где формируется поле Значение, задать
      переменной formatter соответствующий формат.
      (смотри https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html)
   2) WorkWithDatabase.setUpdate : в части обновления таблицы с датами (Update DataTable) для sdf
      задать корректный формат.
      (смотри https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html)
   3) app.js : установить регулярное выражение для проверки корректности вводимой даты в массиве
      dataFormats и подкорректировать сообщение, которое будет выводиться при неправельном формате.
